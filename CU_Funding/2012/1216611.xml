<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>SHF:Small:Disciplined Approximate Programming for Energy-Efficient Computing</AwardTitle>
    <AwardEffectiveDate>10/01/2012</AwardEffectiveDate>
    <AwardExpirationDate>09/30/2015</AwardExpirationDate>
    <AwardAmount>300000</AwardAmount>
    <AwardInstrument>
      <Value>Standard Grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05010000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Division of Computing and Communication Foundations</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>Anindya Banerjee</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>This research aims to make computing systems more energy-efficient, leading to longer battery life for mobile devices and lower energy bills for end users and data centers. The key approach is to identify and exploit portions of computations where approximate results or occasional errors are allowable and use this flexibility to save energy. While sacrificing precision may initially seem unthinkable for computers, it is appropriate for the energy-intensive portions of many applications, such as programs related to multimedia, sensing, or random simulation. While allowing some approximation, one must still insist that only data and code specifically annotated as "approximate" by the programmer is allowed to be imprecise. Moreover, this research will develop techniques for monitoring and enforcing "quality of service", which in this context means the impact that approximation has on the observable output.&lt;br/&gt;&lt;br/&gt;The research necessarily crosses several layers of the conventional computing execution stack. The best way to save energy is via novel hardware that, thanks to approximation, can save energy via various means such as voltage scaling or lower cache refresh rates. But only higher levels of abstraction know where approximation is appropriate, so we need language design and language implementation to communicate this information to the hardware. In addition, programmers need software-development tools for debugging and profiling applications that leverage approximation. The results of this research will include advances in computer architecture, programming language design and implementation, and software tools.</AbstractNarration>
    <MinAmdLetterDate>09/06/2012</MinAmdLetterDate>
    <MaxAmdLetterDate>09/06/2012</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>1216611</AwardID>
    <Investigator>
      <FirstName>Daniel</FirstName>
      <LastName>Grossman</LastName>
      <EmailAddress>djg@cs.washington.edu</EmailAddress>
      <StartDate>09/06/2012</StartDate>
      <EndDate/>
      <RoleCode>Co-Principal Investigator</RoleCode>
    </Investigator>
    <Investigator>
      <FirstName>Luis</FirstName>
      <LastName>Ceze</LastName>
      <EmailAddress>luisceze@cs.washington.edu</EmailAddress>
      <StartDate>09/06/2012</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>University of Washington</Name>
      <CityName>Seattle</CityName>
      <ZipCode>981950001</ZipCode>
      <PhoneNumber>2065434043</PhoneNumber>
      <StreetAddress>4333 Brooklyn Ave NE</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>Washington</StateName>
      <StateCode>WA</StateCode>
    </Institution>
    <ProgramElement>
      <Code>7798</Code>
      <Text>SOFTWARE &amp; HARDWARE FOUNDATION</Text>
    </ProgramElement>
    <ProgramReference>
      <Code>7329</Code>
      <Text>COMPILERS</Text>
    </ProgramReference>
    <ProgramReference>
      <Code>7923</Code>
      <Text>SMALL PROJECT</Text>
    </ProgramReference>
    <ProgramReference>
      <Code>7943</Code>
      <Text>PROGRAMMING LANGUAGES</Text>
    </ProgramReference>
  </Award>
</rootTag>
