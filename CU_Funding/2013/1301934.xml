<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>CSR: Medium: Collaborative Research: The Commutativity Rule for Scalable Systems Software</AwardTitle>
    <AwardEffectiveDate>10/01/2013</AwardEffectiveDate>
    <AwardExpirationDate>09/30/2016</AwardExpirationDate>
    <AwardAmount>299995</AwardAmount>
    <AwardInstrument>
      <Value>Standard Grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05050000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Division Of Computer and Network Systems</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>M. Mimi McClure</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>After decades of reliable improvement, processor speeds have&lt;br/&gt;flattened; for the foreseeable future, computers will add processing&lt;br/&gt;power by adding more processors, rather than faster ones. This is a&lt;br/&gt;tremendous challenge for software designers. It's far too easy for&lt;br/&gt;software using multiple processors to burn up a growing fraction of&lt;br/&gt;available processing power on coordination overheads like locking,&lt;br/&gt;rather than actual work. That is, it's far too easy for software to&lt;br/&gt;not scale: to get slower as processors are added. And an important&lt;br/&gt;reason for this is simply that scalability is poorly understood. Some&lt;br/&gt;programs don't scale because they're badly written, but others don't&lt;br/&gt;scale because their goals are fundamentally impossible to accomplish&lt;br/&gt;in a scalable way. Programmers lack effective tools for high-level&lt;br/&gt;reasoning about software scalability limitations, and thus waste&lt;br/&gt;effort on both impossible and uninteresting tasks.&lt;br/&gt;&lt;br/&gt;We will produce the first well-grounded and formal reasoning procedure&lt;br/&gt;for scalability that is flexible enough to apply to an entire&lt;br/&gt;operating system. Our scalability rule links commutativity and&lt;br/&gt;scalability. We characterize software interfaces as more or less&lt;br/&gt;inherently scalable depending on the contexts in which those&lt;br/&gt;interfaces commute: the more commutative an interface (that is, the&lt;br/&gt;more often the order of its function calls doesn't matter), the more&lt;br/&gt;scalable an implementation can be. We prove that a scalable&lt;br/&gt;implementation exists for any commutative context. This idea can&lt;br/&gt;already guide software designers in developing easily-scalable&lt;br/&gt;interfaces, but we will also provide a set of automated tools for&lt;br/&gt;measuring interface commutativity and for finding implementation&lt;br/&gt;scalability bottlenecks, and evaluate our ideas in a highly-scalable&lt;br/&gt;operating system. The resulting tools and ideas could make scalable&lt;br/&gt;software far easier to design and program, and thus help software&lt;br/&gt;designers provide the software performance on which so much of our&lt;br/&gt;economy depends.</AbstractNarration>
    <MinAmdLetterDate>09/09/2013</MinAmdLetterDate>
    <MaxAmdLetterDate>09/09/2013</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>1301934</AwardID>
    <Investigator>
      <FirstName>Robert</FirstName>
      <LastName>Morris</LastName>
      <EmailAddress>rtm@csail.mit.edu</EmailAddress>
      <StartDate>09/09/2013</StartDate>
      <EndDate/>
      <RoleCode>Co-Principal Investigator</RoleCode>
    </Investigator>
    <Investigator>
      <FirstName>M. Frans</FirstName>
      <LastName>Kaashoek</LastName>
      <EmailAddress>kaashoek@lcs.mit.edu</EmailAddress>
      <StartDate>09/09/2013</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Investigator>
      <FirstName>Nickolai</FirstName>
      <LastName>Zeldovich</LastName>
      <EmailAddress>nickolai@csail.mit.edu</EmailAddress>
      <StartDate>09/09/2013</StartDate>
      <EndDate/>
      <RoleCode>Co-Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>Massachusetts Institute of Technology</Name>
      <CityName>Cambridge</CityName>
      <ZipCode>021394301</ZipCode>
      <PhoneNumber>6172531000</PhoneNumber>
      <StreetAddress>77 MASSACHUSETTS AVE</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>Massachusetts</StateName>
      <StateCode>MA</StateCode>
    </Institution>
    <ProgramElement>
      <Code>7354</Code>
      <Text>COMPUTER SYSTEMS</Text>
    </ProgramElement>
    <ProgramReference>
      <Code>7924</Code>
      <Text>MEDIUM PROJECT</Text>
    </ProgramReference>
  </Award>
</rootTag>
